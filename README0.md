# Начало работы с Octoshell
Ruby on Rails v5.2 написан на языке Ruby, но для знакомства с рельсами
может быть достаточно знать основные принципы ООП и [официального гайда](https://guides.rubyonrails.org/v5.2/).
Octoshell обладает обширной кодовой базой, и здесь есть
множество примеров на разные случаи жизни. Желательно, чтобы новые элементы
Octoshell были похожи на предыдущие.

Octoshell разбит на базовое приложение и модули, реализованные с помощью
стандартного подхода RoR engines. В одноимённой директории engines/ модули и
располагаются. Для интеграции в Octoshell (например, в меню обычного пользователя или
администратора) и корректного межмодульного взаимодействия подход RoR в Octoshell расширен. Чисто технически можно обойтись без расширенного подхода Octoshell,
поэтому модуль можно создать и ограниченно интегрировать просто руководствуясь
инструкциями по работе с модулями на сайте Ruby on Rails, но это не рекомендуется.
Подробнее об расширенном подходе будет сказано в разделе **модули Octoshell**.

И модули, и базовое приложение используют вспомогательные методы из директории
lib/ и по пути engines/face/lib/face/. Чаще всего,
если Вы встречаете незнакомый метод, который не описан в модуле или вспомогательных библиотеках, то его можно найти в этих директориях.




# Часто используемые и полезные библиотеки(гемы) Octoshell
Каждая библиотека доступна на Github:
* **slim** -- инструмент, переводящий  html с элементами кода на Ruby в html.
 В Octoshell используется вместо erb, стандартного в RoR.
* **CanCanCan** -- авторизация.
* **bootstrap_form** генерирует формы, используется вместо стандартного form_for:
если встречаете метод bootstrap_form_for, это означает, что используется именно
"бутстраповская" версия, которая, однако, похожа на исходный form_for.
* **ransack** сильно помогает в создании  форм для фильтрации, преобразовывая поля формы с ключами, написанными по правилам ранзаках, в SQL-запросы.
* **kaminari** -- пагинация для списка объектов.
* **rspec** -- тестирование Ruby проектов.
* **decorator** -- расширение описаний классов вне их модулей.
* **sidekiq** -- выполнение фоновых задач (рассылка почтовых уведомлений, загрузка файлов и т.д. ).
* **rails_email_preview** -- предварительный просмотр почтовых сообщений(полезно при разработке).
* **traco** помогает перевести атрибуты модели на несколько языков, а
пользователю показывать атрибут в зависимости от его языка.

# Права доступа и группы пользователей

Авторизация осуществляется гемом СanСanСan, а это означает, что
все права доступа по идее должны записываться в файле app/models/ability.rb.
Но Octoshell состоит из множества модулей и стремится к тому, чтобы их можно было легко изменять и удалять, в том числе, и их права доступа. Поэтому определять
напрямую права в этом файле, как в документации CanCanCan, запрещено. О
корректном задании прав будет сказано в разделе **модули Octoshell**.




# Модули Octoshell
Octoshell разбит на модули, каждый из которых выполняет свои задачи: например,
модуль hardware управляет информацией о оборудовании суперкомпьютеров.
Каждый модуль реализован с помощью встроенной технологии Ruby on Rails engines.
Этот инструмент предназначен для расширения базового приложения (в octoshell это практически всё не в директрории engines) новой функциональностью.
Примером является engine RailsAdmin, который позволяется управлять данными
любого проекта на Ruby on Rails. Есть различные модуля для форумов и т.д.
Такие модули чаще всего в Ruby on Rails зависимы  только от базового приложения (модули расширяют его функциональность), а базовое приложение совсем не зависит от модулей, которые могут быть запросто удалены/заменены.

Ситуация в Octoshell оказалась иной и разных типов зависимостей было больше:
* зависимости базового приложения от модулей: показать список отчётов пользователя (модуль Sessions) на его странице в базовом приложении,
ссылки на страницы модулей и многие другие.
* зависимости между модулями: ассоциации моделей из разных модулей.

Octoshell стремится к тому, чтобы любой его модуль мог быть при желании просто
удалён, заменён и изменён (как в СКЦ МГУ, так и в любом другом СКЦ, который захотел бы использовать Octoshell)
Раньше каждая такая операция могла затронуть другие части Octoshell, пусть элементы разных модулей взаимодействуют нечасто. Поэтому поверх engines был добавлен новый механизм, реализованный в модуле Octoface для организации межмодульного взаимодействия и встраивания модуля в систему.

# Основные принципы
Для каждого принципа реализован один из инструментов модуля Octoface.


* Каждый модуль имеет в системе свою роль: именованный список интерфейсов для
реализации. Например, модуль Support имеет роль support. Если мы хотим
другой модуль для техподдержки, мы можем взять какой-нибудь engine из Интернета,
дать ему роль support и достроить необходимые интерфейсы.  

* Модули общаются друг с другом с помощью специальных интерфейсов,
обращаясь к имени роли. Если нет модуля, реализующего роль, некорректного
обращения не происходит.

* Иногда нужен прямой доступ к элементу другого модуля, например, при
построении ассоциаций в ActiveRecord. Такие интерфейсы будем называть "класс-класс".
Здесь предлагается выполнить следующие шаги:

  *  "Разрешить"  использование класса вне модуля.
  * За такими разрешенными классами должен осуществляться контроль, поэтому классы,
    где они используются, необходимо помечать.
  * Вызывать методы, зависящие от классов другого модуля, только при условии наличия необходимого модуля в Octoshell.

* Минимальная установка Octoshell состоит из нескольких модулей и базового приложения, поэтому к многим из их элементов допускается обращаться напрямую.

	* Authentication, который отвечает за аутентификацию и регистрацию пользователей.
	* Face, который содержит функциональность, реализующую пользовательский интерфейс и используемую каждым другим модулем.
	* Octoface, который реализует взаимодействие между модулями.

* Настройки каждого модуля для интеграции в систему помещаются в файл lib/<модуль>/settings.rb внутри каждого модуля.


# Интерфейсы
## settings.rb
В первую очередь модуль необходимо расширить(extend) с помощью Octoface.
После чего для модуля можно вызвать метод octo_configure, принимающий на вход
Symbol(название роли) и блок с настройками. После этого за модулем фиксируется выбранная роль.Есть много примеров реальных модулей Octoshell, но для простоты и одновременно полноты мы рассмотрим пример интеграции в Octoshell несуществующего модуля
 ExampleCore с ролью :core.
```ruby
module ExampleCore
  extend Octoface
  octo_configure :core do
    add('Project')
    add_ability(:manage, :projects, 'superadmins')
    add_ability do |user|
      if can?(:access, :admin)
        can :access, ExampleCore::Topic
      end
    end
    add_controller_ability(:manage, :projects, 'admin/projects',
                           'admin/project_kinds', 'admin/direction_of_sciences',
                           'admin/critical_technologies', 'admin/research_areas',
                           'admin/group_of_research_areas')
  end
end
```

## add_ability

Блок с настройками передаётся для исполнения классу Octoface::OctoConfig,
смотрите его документацию для использования его возможностей. Также имеется
много примеров использования.

### Face::MyMenu
Метод Face::MyMenu.add_item предназначен для добавления элемента меню (ссылки на
  модуль в главное меню пользователя).
* Первый аргумент -- уникальный ключ элемента.
* Второй аргумент -- название элемента.
* Третий аргумент -- путь (строка или регулярное выражение).
  Если он совпадает с текущим путём контроллера(params[:controller]), то пункт
  подсвечивается синим, что означает его активность.

Вариация метода  Face::MyMenu.add_item_if_may добавит для пользователя пункт меню,
если установлена связь между ability и контроллером с помощью OctoConfig#add_controller_ability и
у пользователя есть данная ability.


## Межмодульный интерфейс для представлений
В представления довольно частая ситуация, когда нужно обратиться к
элементам другого модуля. Здесь предлагается использовать метод custom_helper,
который передаёт все свои аргументы в метод handle_view класса Interface
модуля требуемой роли, если модуль присутствует в системе. Пример:
```
= custom_helper(:core, 'project_critical_technologies_id_in', f,
                label: t('.critical_technologies_id_in') )
```
Допускаются и другие пользовательские варианты. Для описания полей можно
описать наследника класса BootstrapFormHelper, если посчитаете, что он
облегчает описание методов. Такие наследники в Octoshell есть,
обращайтесь к ним за примерами.

## Межмодульное взаимодействие на уровне моделей
Здесь используются интерфейсы "класс-класс".
Проще рассмотреть на примере Ruby модуля Sessions::ReportProject,
который подмешивается(prepend) в Sessions::Report, если в системе есть модуль с ролью
core и внутри него модель "Проект".

Используется метод octo_use, который добавляет вспомогательные методы и записывает факт того, что класс Project
используется классом Report. Это можно посмотреть на странице /octoface/admin/roles
(в development-окружении из-за динамической подгрузки не всегда отображается верно).
Также осуществляется проверка того, что Project "разрешён"(на уровне соглашения)
к использованию вне модуля core. Смотрите модуль Octoface::Usage для деталей.

## link? и add_link
Эти простые методы позволяют отключать/включать функциональность. Смотрите
engines/sessions/lib/sessions.rb как пример.

## Hooks
Чистых межмодульных интерфейсов иногда недостаточно. Иногда нужно определять "место"
для встраивания других модулей. Например, информация о пользователе распределена между
модулями, а на его странице в панели администратора нужно видеть и отчёты из модуля Sessions,
и проекты из модуля Core и многое другое. Здесь помогают хуки.

На данный момент в Octoshell хуки используются  только для представлений.
В примере ниже регистрируется место для хука admin_users_show для роли main_app (базовое приложение)
 и передаётся аргумент по ключу user(должны же знать другие модули для какого именно пользователя надо отображать данные):
```
  /app/views/admin/users/show.html.slim
  = register_hook_place(:main_app,:admin_users_show, { user: @user })
```
Модуль Core добавляет  хук-представление core/hooks/admin_users_show
```ruby
  engines/core/lib/core.rb
  Octoface::ViewHook.add_hook(:core, "core/hooks/admin_users_show",
                          :main_app, :admin_users_show)
```

Представление выглядит следующим образом:
```
  = render "core/admin/employments/list", employments: user.employments.where(state: :active).order(primary: :desc, created_at: :desc)
  h4 = User.human_attribute_name(:projects)
  = render 'core/projects/projects_list', projects: user.projects.order(created_at: :desc)
  = render "core/admin/credentials/list", credentials: user.credentials.where(state: :active)
```

Места и хуки можно посмотреть на странице /octoface/admin/roles.





This project uses MIT-LICENSE.
