# Начало работы с Octoshell
Octoshell реализован на платформе Ruby on Rails v5.2.
И Octoshell, и платформа  написаны главным образом  на языке Ruby.
Для знакомства с рельсами может быть достаточно знать основные принципы ООП и [официального гайда](https://guides.rubyonrails.org/v5.2/), а для знакомства c возможностями Octoshell -- с помощью этого руководства.

Octoshell обладает обширной кодовой базой, и здесь есть
множество примеров на разные случаи жизни. Желательно(но не обязательно!), чтобы новые элементы Octoshell были похожи на предыдущие, что означает, например,
использование таких же библиотек.


# Как читать данное руководство

В Octoshell много разных возможностей и вываливать их все сразу
на неокрепшие умы -- плохо. Поэтому руководство для начинающих заканчивается
после **settings.rb (основные функции)**. Там описаны вещи, без которых в Octoshell
будет работать тяжело и неуютно. Это руководство рассчитано на тех, кто смог создать контроллер, модели внутри модуля Ruby on Rails (модуля без специфики Octoshell).

Дальше уже начинаются вещи посложнее: как в Octoshell осуществлять корректное
взаимодействие между модулями. Даже если это очень нужно уже начинающему, для начала можно осуществлять взаимодействие "напрямую" без средств Octoshell, но рекомендуется
не увлекаться, потом всё-таки прочитать последние главы руководства.


# Часто используемые и полезные библиотеки(гемы) Octoshell
Каждая библиотека доступна на Github:
* **slim** -- инструмент, переводящий  html с элементами кода на Ruby в html.
 В Octoshell используется вместо erb, стандартного в RoR.
* **CanCanCan** -- авторизация.
* **bootstrap_form** генерирует формы, используется вместо стандартного form_for:
если встречаете метод bootstrap_form_for, это означает, что используется именно
"бутстраповская" версия, которая, однако, похожа на исходный form_for.
* **ransack** сильно помогает в создании  форм для фильтрации, преобразовывая поля формы с ключами, написанными по правилам ранзаках, в SQL-запросы.
* **kaminari** -- пагинация для списка объектов.
* **rspec** -- тестирование Ruby проектов.
* **decorator** -- расширение описаний классов вне их модулей.
* **sidekiq** -- выполнение фоновых задач (рассылка почтовых уведомлений, загрузка файлов и т.д. ).
* **rails_email_preview** -- предварительный просмотр почтовых сообщений(полезно при разработке).
* **traco** помогает перевести атрибуты модели на несколько языков, а
пользователю показывать атрибут модели в зависимости от его языка.


# Модули Octoshell
Octoshell разбит на модули, каждый из которых выполняет свои задачи: например,
модуль hardware управляет информацией о оборудовании суперкомпьютеров.
Каждый модуль реализован с помощью встроенной в платформу Ruby on Rails технологии  engines.
Этот инструмент предназначен для расширения базового приложения (в octoshell это практически всё не в директории engines) новой функциональностью.
Примером является известный в RoR engine **RailsAdmin**, который позволяется управлять данными почти любого проекта на Ruby on Rails. Есть различные модулb для форумов и т.д.
Такие модули чаще всего в Ruby on Rails зависимы  только от базового приложения (модули расширяют его функциональность), а базовое приложение совсем не зависит от модулей, которые могут быть запросто удалены/заменены.

Ситуация в Octoshell оказалась иной и разных типов зависимостей было больше:
* зависимости базового приложения от модулей: показать список отчётов пользователя (модуль Sessions) на его странице в базовом приложении,
ссылки на страницы модулей и многие другие.
* зависимости между модулями: ассоциации моделей из разных модулей.

Octoshell стремится к тому, чтобы любой его модуль мог быть при желании просто
удалён, заменён и изменён (как в СКЦ МГУ, так и в любом другом СКЦ, который захотел бы использовать Octoshell)
Раньше каждая такая операция могла затронуть другие части Octoshell, пусть элементы разных модулей взаимодействуют нечасто. Поэтому поверх engines был добавлен новый механизм, реализованный в модуле Octoface для организации межмодульного взаимодействия и встраивания модуля в систему.


# Основные принципы модулей Octoshell

* Каждый модуль имеет в системе свою роль: именованный список интерфейсов для
реализации. Например, модуль Support имеет роль support. Если мы хотим
другой модуль для техподдержки, мы можем взять какой-нибудь engine из Интернета,
дать ему роль support и достроить необходимые интерфейсы.  

* Модули общаются друг с другом с помощью специальных интерфейсов,
обращаясь к имени роли. Если нет модуля, реализующего роль, некорректного
обращения не происходит.

* Иногда нужен прямой доступ к элементу другого модуля, например, при
построении ассоциаций в ActiveRecord. Такие интерфейсы будем называть "класс-класс".
Здесь предлагается выполнить следующие шаги:

  *  "Разрешить"  использование класса вне модуля.
  * За такими разрешенными классами должен осуществляться контроль, поэтому классы,
    где они используются, необходимо помечать.
  * Вызывать методы, зависящие от классов другого модуля, только при условии наличия необходимого модуля в Octoshell.

* Минимальная установка Octoshell состоит из нескольких модулей и базового приложения, поэтому к многим из их элементов допускается обращаться напрямую.

	* Authentication, который отвечает за аутентификацию и регистрацию пользователей.
	* Face, который содержит функциональность, реализующую пользовательский интерфейс и используемую каждым другим модулем.
	* Octoface, который реализует взаимодействие между модулями и между модулями и основным приложением.

* Настройки каждого модуля для интеграции в систему помещаются в файл lib/<модуль>/settings.rb внутри каждого модуля.







# settings.rb (основные функции)
Пусть у нас есть модуль ExampleCore, находящийся по директории
engines/example_core. Создадим файл lib/example_core/settings.rb в директории
модуля. Чтобы файл был загружен необходимо в lib/example_core.rb прописать:

```ruby
  require "example_core/settings" if defined?(Octoface)

```

Условие **if defined?(Octoface)** проверяет подгружен ли модуль Octoface.
Дело в том, что, например, создавая новую модель внутри модуля командой rails g,
будут загружены только зависимости модуля, а не Octoshell в целом. В зависимостях
модулях Octoface нет, и rails g внутри модуля вылетит с ошибкой без этого условия.
Перейдём к самим настройкам. Пояснения каждого метода будут ниже.

```ruby
module ExampleCore
  extend Octoface
  octo_configure :core do
    add_ability(:manage, :projects, 'superadmins')

    add_ability do |user|
      if can?(:access, :admin)
        can :read, ExampleCore::Topic, id: 1
      end
    end
    add_controller_ability(:manage, :projects, 'admin/projects',
                           'admin/project_kinds')
    add_routes do
      mount ExampleCore::Engine, :at => "/example_core"
    end

    after_init do
      Face::MyMenu.items_for(:admin_submenu) do
        if can? :manage, :projects
          add_item('projects', t('admin_submenu.projects'),
                    example_core.admin_projects_path, %r{^example_core/admin/projects})

          add_item('research_projects', t('admin_submenu.research_projects'), example_core.admin_research_projects_path,
          'example_core/admin/research_projects')
        end
        add_item_if_may('project_kinds', t("admin_submenu.project_kinds"), example_core.admin_project_kinds_path, 'example_core/admin/project_kinds')

      end

      Face::MyMenu.items_for(:user_submenu) do
        tickets_warning = current_user.tickets.where(state: :answered_by_support).any?
        tickets_title = if tickets_warning
                          t("user_submenu.tickets_warning.html").html_safe
                        else
                          t("user_submenu.tickets")
                        end
        add_item('tickets', tickets_title, example_core.tickets_path, /^example_core/)
      end
    end
  end
end
```

##octo_configure
  Припишем нашему модулю роль :core. В первом аргументе роль и передаётся, дальше
  открывается блок, в котором все настройки и будут записаны.


## add_ability (Права доступа и группы пользователей)


Авторизация осуществляется гемом СanСanСan, а это означает, что
все права доступа по идее должны записываться в файле app/models/ability.rb.
Но Octoshell состоит из множества модулей и стремится к тому, чтобы их можно было легко изменять и удалять, в том числе, и их права доступа. Поэтому определять
напрямую права в этом файле, как в документации CanCanCan, запрещено.

В Octoshell права доступа можно задать несколькими способами. Рекомендованный
способ заключается в определении прав доступа на основе **группы пользователя**.
Всё просто: мы пишем, что есть вот такое право доступа, которое можно
редактировать прямо в браузере в разеле "группы доступа". Причём есть возможность
и задать какие группы получают данное право по-умолчанию: не хочется же всё время
их задавать в браузере при накатывании базы данных для development режима, когда можно заполнить тестовыми данными. Неблочный вариант **add_ability** за это и отвечает:
add_ability(:manage, :projects, 'superadmins'). Создаём право осуществлять действие
:manage над :projects и выдаём это право только для группы 'superadmins'. Обратите внимание на принимаемые типы. Для суперадмина  can?(проверка прав) вернёт true:

```ruby
  can?(:manage, :projects) #=> true
```

Второй вариант add_ability является обычным для гема CanCanCan: мы определяем,
что можно уже для конкретного экземпляра модели и пользователя. И уже можно будет пользоваться методами CanCanCan, которые он добавляет в модель. В начале раздела
было написано, что нельзя напрямую писать в файл ability.rb, но можно открыть
блок(do end) в add_ability и писать ровно также, как в обычный файл ability.rb под управлением гема CanCanCan. Переменная блока user даёт доступ к экземпляру модели пользователя Octoshell, для которого и будет решаться какие права ему выдавать,
а какие нет, т.е. этот блок кода будет выполняться для пользователя
каждый раз, когда он проходит по URL в Octoshell (здесь явная совместимость с CanCanCan).
В примере выше если пользователь имеет доступ в кабинет администратора, то он может читать топик с id равным единице, т.е.

```ruby
  can?(:read, ExampleCore::Topic.find(1)) #=> true
```



## add_controller_ability (Связь прав и контроллеров)

В Octoshell права доступа часто связаны с контроллерами: если прав доступа у пользователя нет, то и доступа ко всему контроллеру нет! Метод **add_controller_ability** и осуществляет такую связь. Первые два аргумента
определяют права, остальные -- пути к контроллерами. **Путь** очевидно связан с названием класса, наверняка это можно узнать,
вызвав внутри экшна *params[:controller]* и выкинув название модуля.
В примере выше мы связали право *:manage, :projects* с двумя контроллерами,
отвечающими за редактирование информации о проекте.

Чтобы неавторизованного пользователю был запрещен доступ, в этом случае  внутри контроллера надо прописать:

```ruby
before_action :octo_authorize!
```

Этим методом необязательно пользоваться. Например, в модуле pack все права
администратора связаны с одним правом доступа, и вместо octo_authorize! и add_controller_ability в engines/pack/app/controllers/pack/admin/application_controller.rb
написано следующее:

```ruby
  before_action do
    authorize! :manage, :packages
  end
```

*authorize!* -- это уже метод, подмешиваемый в контроллеры гемом CanCanCan.
Бросается специальное исключение, обработка которого одинакова во всех
контроллерах Octoshell(метод *not_authorized* в
  app/controllers/application_controller.rb).


*authorize!* -- это уже метод, подмешиваемый в контроллеры гемом CanCanCan.
Бросается специальное исключение, обработка которого одинакова во всех
контроллерах Octoshell(метод *not_authorized* в
  app/controllers/application_controller.rb).


## add_routes (добавить роуты модуля)

  Роутер Rails распознает URL и направляет его в экшн нужного контроллера,
  но на данный момент модуль роутер Rails не видит. В руководстве по
  Ruby on Rails предлагается в главный конфиг роутинга  config/routes.rb просто
  прописать:
  ```ruby
    mount ExampleCore::Engine, :at => "/example_core"
  ```
  Но так делать не следует: удаляя, заменяя модуль придётся снова редактировать
  файл, который к модулю отношения не имеет! Поэтому откроем блок метода
  *add_routes* и пропишем эту же строчку внутри блока. Открывая этот блок,
  мы по сути получаем доступ к главном конфигу для роутинга!

## after_init

Некоторые действия в Ruby on Rails можно выполнять только после того, как,
например, все модели загружены, иначе Octoshell будет падать при его запуске.
Блок кода, переданный в данный метод выполнится только после того, как все
модели будут загружены системой, точнее после того, как все инициализаторы
(config/initializers) отработают.  Блоки кода из методов выше
по сути выполняются в этот же момент запуска приложения.


## Face::MyMenu.items_for (добавить пункты меню  в меню пользователей)

Перед тем как перейти к описанию метода, обсудим, что должно быть
у пункта меню в Octoshell.

* У пункта меню должно быть название, при этом на нескольких языках.
* У пункта меню должен быть URL.
* Активный в данный момент пункт меню должен подсвечиваться, чтобы пользователь
понимал, где он находится.
* Пункт должнен принадлежать меню обычного пользователя или  администратора.
* Пункт меню можно менять местами и храниться в базе данных, чтобы
  предпочтения пользователя сохранялись. Для этой задачи пункту нужен
  специальный ключ: ведь другие атрибуты пункта могут быть изменены.  
* В Octoshell задан порядок пунктов меню по-умолчанию.

Перейдём к реализации. Cначала нужно вызвать метод *Face::MyMenu.items_for*
и передать ему название меню: администратора(*:admin_submenu*) или обычного
пользователя(*:user_submenu*). Блок кода для этого метода будет вызван внутри
контроллера при его работе, т.е. каждый раз, когда пользователь переходит по ссылке
Octoshell. Здесь доступны методы из контроллера *t, can? и current_user* (последний для доступа к модели пользователя, выполняющего сейчас запрос).


Самый важный метод здесь *add_item*, он и добавляет в меню пользователя пункты.
* Первый аргумент -- уникальный ключ элемента.
* Второй аргумент -- название элемента для показа кода.
* Третий аргумент и далее -- путь (строка или регулярное выражение).
  Если он совпадает с текущим путём контроллера(params[:controller]), то пункт
  выделяется синим цветом или рамкой, что означает его активность. Так как здесь
  переменное число аргументов, несколько контроллеров могут выделяться одним элементом
  меню. Можно комбинировать несколько строк и регулярных выражений.


В примере  мы спрашиваем пользователя, может ли он работать с проектами:
ему не зачем знать о пункте, перейдя по которому его выкинет на страницу "У вас нет прав"(если конечно в самом контроллере не забыли спросить права).
Дальше добавляем пункты меню для доступа в проекты и исследования проектов.
Первый пункт будет активен, если путь контроллера начинается на "example_core/admin/projects"(там же регулярное выражение!), второй -- если путь контроллера совпадает с "example_core/admin/research_projects" (здесь уже строка).

Вариант метода Face::MyMenu.add_item_if_may добавит для пользователя пункт меню,
если установлена связь между правом доступа и контроллером, чей путь записан
в третьем аргументе. А связь устанавливается уже знакомым add_controller_ability,
в том числе и поэтому был добавлен этот неудобный на первый взгляд метод.
Обратите внимание, что при переходе по новоиспечённому пункту "Виды проектов",
подсвечиваться будут и этот пункт, и самый первый наш пункт "Проекты", что на
самом деле неправильно, и такое бывает из-за неаккуратности.

Наконец, добавляем пункт "тикеты" (заявки в техподдержку) для пользователей.
Если у пользователя есть тикеты с ответом техподдержки, будет добавлен html, привлекающий внимание. Смысл этого примера в том, что в таких блоках
можно свободно объявлять переменные и обращаться к базе данных.




## Межмодульное взаимодействие
### Введение

Основные функции settings.rb позволяют облегчить интеграцию модуля в Octoshell,
таким образом отделяя функциональность модуля Octoshell от базового приложения.
Эти функции и названы основными, так как без них не обойтись, но
модули иногда могут взаимодействовать ещё и друг с другом.
Эта глава будет о том, как правильно осуществлять такое взаимодействие на основе
реальных примеров из жизни Octoshell.

Перейдём сразу к одному из таких примеров. В ходе перерегистрации пользователи
заполняют отчёты (Reports) из модуля Sessions. Отчёт может быть ассоциированы с
проектом (Projects) из модуля Core, работу в котором пользователь и описывает.
Если отчёт получает плохую оценку, то проект блокируется.

Самый простой способ реализовать такую связь -- это связать эти модели так,
как будто они находятся в одном модуле с помощью стандартных средств Ruby on
Rails (раньше в Octoshell так и делалось). Для модели отчёта тогда будем иметь:

```ruby
  belongs_to :project, class_name: 'Core::Project',
                       foreign_key: :project_id
  def block_project
    project.block!
  end
```

При изменении состава модуля появляются  следующие проблемы:
* Модуль Core удалён из текущей конфигурации Octoshell -- обращение к константе
Core::Project приводит к исключениям, и Octoshell не работает.
* Изменена логика проекта, предположим, что его больше нельзя заблокировать. Тогда
метод block_project будет бросать исключение тоже.
После таких изменений в проекте надо искать функциональность, которая связана
с блокированием проекта во всём модуле Sessions: а она была бы
спрятана в файлах моделей report.rb и session.rb. Также при просмотре отчёта на
странице модуля Sessions доступна информация о проекте, а это значит, что и
во вьюхах надо тоже всё проверить.


### Интерфейс "класс-класс"

Поясним работу интерфейса "класс-класс" на реальном примере из введения (код из листингов ниже уже описан).
Как говорилось ранее,
межмодульное взаимодействие можно оборачивать в интерфейсы модулей, но здесь решено
было использовать именно "класс-класс", т.к. в противном случае (при использовании
интерфейсов модулей), не получилось бы использовать ассоциации Ruby on Rails,
на основе которых работают такие известные гемы как **Ransack** и
полезные встроенные средства, решающие, например, проблему N+1 запроса.
Для начала, нужно пометить класс Core::Project, что он будет использоваться вне
его модуля. А делается это в настройках модуля *engines/core/lib/core/settings.rb*:

```ruby
  module Core
    extend Octoface
    octo_configure :core do
      add('Project')
    end
  end
```

Дальше в веб-интерфейсе администратора в разделе **модули Octoshell** этот факт будет зафиксирован: на странице */octoface/admin/roles/core*  показано, что Project
используется вне его класса напрямую,а также -- классы, которые используют его
напрямую. Стоит обратить внимание, что в режиме development не все классы будут показаны,
а лишь те, которые успели прогрузиться. Также нет никаких технических ограничений
на использование константы Core::Project (и любых других  классов модулей вне их модулей), это всего лишь соглашение в Octoshell.

Для удобной работы с зависимостями для модулей Octoshell был добавлены методы
**add_link** и **link?**. Чисто технически они делают следующее: **add_link**
добавляет Symbol в массив, а **link?** проверяет, есть ли Symbol
в данном массиве. С одной стороны, это синтаксический сахар: не хочется всегда
проверять есть ли модуль, реализующий роль, и класс, разрешённый (помеченный)
для его использования вне модуля, с помощью многословной конструкции
*::Octoface.role_class?(:core, 'Project')*, с другой стороны так можно задавать
сложные зависимости и отключать функциональность, даже если технически для её
воплощения всё присутсвует в системе.  Ниже фрагмент кода из
engines/sessions/lib/sessions.rb. Если есть модуль, реализующий роль **:core** и
класс **Project**, разрешённый (помеченный) для его использования вне модуля, то
добавить связь **:project**. После этого если есть связь **:project**, то
загружаем файл engines/sessions/lib/sessions/report_project.rb. В результате первый if
играет роль конфигурации.

```ruby
module Sessions
  if ::Octoface.role_class?(:core, 'Project')
    add_link :project
  end
end
```

Если рассматривать уровень модели, то от Core::Project зависит немного, и
в принципе можно было прямо в коде модели (*engines/sessions/app/models/sessions/report.rb*) расставлять условные конструкции примерно так:

```ruby
module Sessions
  class Report
    #...
    #...
    def notify_about_assess
      Sessions::MailerWorker.perform_async(:report_assessed, id)
      if Sessions.link?(:project)
        return unless failed?
        block_project
      end
    end

    def block_project
      project.block! unless project.blocked? || project.finished? ||
                            project.cancelled?
    end
  end
end
```

Метод notify_about_assess выполняется после того, как отчёт оценен.
Отправляется уведомление о получении оценки, и если отчёт находится в состоянии
*failed*, то связанный с отчётом проект блокируется.

Однако файл модели может быть большим, таких if-ов много, что затрудняет понимание.
В данном случае был "подмешан" Ruby модуль с помощью *prepend*, внутри которого "проектная" функциональность и была изолирована. Что делает в Ruby *prepend*?
Подмешиваемый с prepend модуль встраивается в начало цепочки наследования, стоит
даже впереди самого класса, где использован prepend. Если в "препендинном"
модуле вызвать super внутри какого-либо метода, то будет выполняться одноимённый
метод из класса.

Использовано это свойство языка Ruby было так (ниже пока упрошённая версия):

```ruby
## класс отчёта
module Sessions
  class Report
    prepend(ReportProject) if Sessions.link?(:project)
    #...
    #...
    def notify_about_assess
      Sessions::MailerWorker.perform_async(:report_assessed, id)
    end
  end
end
```

```ruby
# подмешиваемый модуль
module Sessions
  module ReportProject
    #...
    #...
    def notify_about_assess
      super
      return unless failed?
      block_project
    end
  end
end
```

Таким образом в методе *ReportProject#notify_about_assess* при вызове
выполняет одноимённый метод из наследника(*Report#notify_about_assess*) и дальше выполняет свою проектную функциональность. Если с помощью add_link связь
:project не добавлялась, то ReportProject не подмешивается. Надо не забыть
загрузить файл с этим модулем, а это уже было сделано в файле engines/sessions/lib/sessions.rb. Дополним его описание так:

```ruby
module Sessions
  if ::Octoface.role_class?(:core, 'Project')
    add_link :project
  end

  if Sessions.link?(:project)
    require "sessions/report_project"
  end
end
```



Реальный Sessions::ReportProject выглядит чуточку сложнее и сейчас будет объяснён:

```ruby
module Sessions
  module ReportProject
    def self.prepended(base)
      base.class_eval do
        octo_use(:project_class, :core, 'Project')
        belongs_to :project, class_name: project_class_to_s,
                             foreign_key: :project_id
      end
    end

    def notify_about_assess
      super
      return unless failed?

      block_project
    end

    def postdate_callback
      super
      block_project
    end

    def block_project
      project.block! unless project.blocked? || project.finished? ||
                            project.cancelled?
    end

    def close_project!
      Sessions::MailerWorker.perform_async(:project_failed_session, id)
      project.block!
    end
  end
end
```

Callback **prepended** срабатывает каждый раз, когда модуль подмешивается с
помощью prepend. В нашем случае описание класса, переданного через аргумент
*base*(в нашем случае Report), расширяется c *class_eval*. Метод **octo_use(name, role,class)** - это дополнительный метод от Octoface, добавленный в каждый класс Octoshell. Он делает следующеее:
* Записывает, что класс(или модуль), откуда был вызван метод, зависит от класса, доступного по паре [role,class]. Все такие записи можно посмотреть на странице роли */octoface/admin/roles/<role>*.
* Добавляет методы класса и экземпляра с названием названием *name*, по которому будет доступен класс по паре (role, class) внутри методов класса. Иначе пришлось бы писать
многословно: eval(Octoface.mod_class_string(role, class)).
* Добавляет методы класса и экземпляра с названием названием *<name>_to_s*, по которому
будет доступно название класса из пункта выше. При использовании *name.to_s* может броситься исключение, если класс с названием *name* ещё не загрузился в Octoshell, поэтому такой метод не будет лишним.

**belongs_to** -- стандартный метод Ruby on Rails. Метод **project_class_to_s** добавлен вызовом метода octo_use.  

В контроллерах можно также всё покрыть if-ами или же воспользоваться трюками с наследованием.
В представлениях используются только if. Например, область исследований доступна администратору на странице списка отчётов, если есть проекты:
```html
  - if Sessions.link?(:project)
    th = project_class.human_attribute_name(:research_areas)
```

### Поля фильтрации для форм
Рассмотрим связь отчётов и проектов. На странице списка отчётов администратор
иногда хочет отфильтровать отчёты по проектам, принадлежащим таким-то группам областей исследований.
Таких полей, зависящих от проекта, на самом деле много. Если не думать о модульности, они выглядели примерно бы так:

```ruby
  = f.collection_select :project_group_of_research_areas_id_in,    Core::GroupOfResearchArea.order_by_name, :id, :name, {label: t('.group_of_research_areas_id_in'),  include_blank: true}, multiple: true
```

Здесь можно выделить следующие проблемы:
* **:project_group_of_research_areas_id_in**  - это Symbol, по которому Ransack будет
строить запрос к СУБД с помощью Rails-ассоциаций. Уже здесь заметна привязка к модулю Core, ведь название ассоциации у проектов - это не дело модуля Core.
* **Core::GroupOfResearchArea**  - это явное обращение к константе другого модуля.

Чтобы скрыть детали модуля Core, здесь были использованы межмодульные интерфейсы Octoshell. Предлагается использовать метод custom_helper:

```ruby
- if Sessions.link?(:project)
  = custom_helper(:core, 'project_group_of_research_areas_id_in', f, '',
                  label: t('.group_of_research_areas_id_in') )

```

Метод custom_helper (о смысле его аргументов пока не задумывайтесь) делает следующие:
Если есть модуль с ролью :core, то из класса Interface данного модуля вызвать метод
handle_view и передать в него все аргументы метода, НО вместо названия роли передаётся
объект ActionView::Base (он необходим для рендеринга прямо из обычного Ruby класса). Как будет сделан класс Interface уже целиком зависит от разработчика модуля. Для Core класс Interface решено было реализовать следующим образом.

```ruby
module Core
  class Interface
    class << self
      def handle_view(view, helper, *args)
        if args[0].is_a? ActionView::Helpers::FormBuilder
          BootstrapFormHelper.new(view, *args).try(helper)
        end
      end
    end
  end
end
```

Если в качестве первого аргумента передаётся наследник ActionView::Helpers::FormBuilder (это аргумент f из вызова выше), то создать экземпляр класса Core::BootstrapFormHelper, передать в него аргументы и попробовать вызвать(try) метод (в примере выше 'project_group_of_research_areas_id_in').

**Core::BootstrapFormHelper** - это простой Ruby класс, целиком опредёленный в Octoshell, но который является наследником класса
**Octoface::BootstrapFormHelper**. Самое время обратить внимание на
смысл аргументов, передаваемых в *custom_helper*, ведь чуть-чуть с
BootstrapFormHelper мы уже познакомились. Рассмотрим на примере выше:
*  **:core** -- роль модуля для вызова интерфейса.  
*  **'project_group_of_research_areas_id_in'** -- название метода.  
*  **f** -- объект формы (а куда без него, если в результате срабатывания custom_helper новое поле появиться как-раз у этой формы).  
*  **''** -- префикс. О нём будет ниже.
*  **{label: t('.group_of_research_areas_id_in')}** -- options. Стандартные опции для форм Ruby on Rails, в которых можно передать  label для поля формы.
*  **{}(не задействовано в этом примере)** -- стандартные HTML опции для форм Ruby on Rails.

Метод **project_group_of_research_areas_id_in** в **Core::BootstrapFormHelper** выглядит следующим образом (engines/core/lib/core/bootstrap_form_helper.rb):

```ruby
module Core
  class BootstrapFormHelper < Octoface::BootstrapFormHelper
    # ...
    # ...
    def project_group_of_research_areas_id_in
      options[:include_blank] ||= true
      f.collection_select prefix + 'project_group_of_research_areas_id_in',
                          Core::GroupOfResearchArea.order_by_name,
                          :id, :name, options, multiple: true
    end
  end
end
```

* options, html_options, prefix -- можно получить с помощью соответствующих методов.
* Название метода почти совпадает с ключом для Ransack, но в принципе это не требуется, а здесь сделано для удобства.
* С помощью prefix можно определить "путь" к проекту, если он связан не напрямую, а через другие классы. Обращайтесь к документации Ransack для полного понимания.
* options, html_options, prefix не подаются как аргументы метода для удобства, иначе все методы были бы отягощены ещё и повторящимися из раза в раз аргументами.
* options, html_options, prefix не подаются как аргументы метода для удобства, иначе все методы были бы отягощены ещё и повторящимися из раза в раз аргументами.
* методы представления можно вызывать также как, во вьюхи. method_missing передаст их
View объекту(вот почему важно было неявно передать этот объект).

 Octoface::BootstrapFormHelper опредён здесь: engines/octoface/lib/octoface/bootstrap_form_helper.rb. Для понимания возможно проще ознакомиться с кодом напрямую.

###set (Условная инициализация)
Иногда при загрузке Octoshell требуется выполнить операцию следующего рода:
"Если существует два модуля заданной роли, то выполнить следующую операцию".
Реальным примером для такой операции является создание "объектных" полей формы в заявках на техподдержку: пользователь должен уметь указать с каким проектом и на каком кластере у него произошла проблема, а модели Core::Cluster, Core::Project и Support::Ticket лежат в разных модулях.

Реализовано было это следующим образом(engines/core/lib/core/settings.rb):
```ruby
module Core
  extend Octoface
  octo_configure :core do
    #...
    #...
    set :support do
      ticket_field(key: :cluster,
                   admin_link: proc { |id| can?(:manage, :clusters) ? core.admin_cluster_path(id) : nil },
                   user_query: proc { Cluster.where(available_for_work: true) },
                   admin_query: proc { Cluster.all })

      ticket_field(key: :project,
                   # метод для отображения объекта, если не указано, то :to_s
                   human: :title,
                   # Если есть права, показать в админке значение со ссылкой на проект
                   admin_link: proc { |id| core.admin_project_path(id) },
                   # Если есть права, показать в рабочем кабнете ссылку
                   user_link: proc { |id| core.project_path(id) },
                   # Запрос для пользовательской версии
                   user_query: proc { |user| user.projects },
                   # Поиск по аяксу в админке
                   admin_source: proc { core.projects_path })


    end
  end
end
```

set(**роль**) работает так: если есть модуль, реализующий **роль**, то выполнить
следующие методы(ticket_field) из его класса Interface(Support). В том числе поэтому роль в Octoshell -- именованный список интерфейсов для реализации, т.е. каждый модуль с ролью support должен уметь добавлять объекты для полей формы.


This project uses MIT-LICENSE.
