# Модули Octoshell
Octoshell разбит на модули, каждый из которых выполняет свои задачи: например,
модуль hardware управляет информацией о оборудовании суперкомпьютеров.
Каждый модуль реализован с помощью встроенной технологии Ruby on Rails engines.
Этот инструмент предназначен для расширения базового приложения (в octoshell это практически всё не в директрории engines) новой функциональностью.
Примером является engine RailsAdmin, который позволяется управлять данными
любого проекта на Ruby on Rails. Есть различные модуля для форумов и т.д.
Такие модули чаще всего в Ruby on Rails зависимы  только от базового приложения (модули расширяют его функциональность), а базовое приложение совсем не зависит от модулей, которые могут быть запросто удалены/заменены.

Ситуация в Octoshell оказалась иной и разных типов зависимостей было больше:
* зависимости базового приложения от модулей: показать список отчётов пользователя (модуль Sessions) на его странице в базовом приложении,
ссылки на страницы модулей и многие другие.
* зависимости между модулями: ассоциации моделей из разных модулей.

Octoshell стремится к тому, чтобы любой его модуль мог быть при желании просто
удалён, заменён и изменён (как в СКЦ МГУ, так и в любом другом СКЦ, который захотел бы использовать Octoshell)
Раньше каждая такая операция могла затронуть другие части Octoshell, пусть элементы разных модулей взаимодействуют нечасто. Поэтому поверх engines был добавлен новый механизм, реализованный в модуле Octoface для организации межмодульного взаимодействия и встраивания модуля в систему.

# Основные принципы
Для каждого принципа реализован один из инструментов модуля Octoface.


* Каждый модуль имеет в системе свою роль: именованный список интерфейсов для
реализации. Например, модуль Support имеет роль support. Если мы хотим
другой модуль для техподдержки, мы можем взять какой-нибудь engine из Интернета,
дать ему роль support и достроить необходимые интерфейсы.  

* Модули общаются друг с другом с помощью специальных интерфейсов,
обращаясь к имени роли. Если нет модуля, реализующего роль, некорректного
обращения не происходит.

* Иногда нужен прямой доступ к элементу другого модуля, например, при
построении ассоциаций в ActiveRecord. Такие интерфейсы будем называть "класс-класс".
Здесь предлагается выполнить следующие шаги:

  *  "Разрешить"  использование класса вне модуля.
  * За такими разрешенными классами должен осуществляться контроль, поэтому классы,
    где они используются, необходимо помечать.
  * Вызывать методы, зависящие от классов другого модуля, только при условии наличия необходимого модуля в Octoshell.

* Минимальная установка Octoshell состоит из нескольких модулей и базового приложения, поэтому к многим из их элементов допускается обращаться напрямую.

	* Authentication, который отвечает за аутентификацию и регистрацию пользователей.
	* Face, который содержит функциональность, реализующую пользовательский интерфейс и используемую каждым другим модулем.
	* Octoface, который реализует взаимодействие между модулями.

* Настройки каждого модуля для интеграции в систему помещаются в файл lib/<модуль>/settings.rb внутри каждого модуля.


# Интерфейсы
## settings.rb
В первую очередь модуль необхомо расширить(extend) с помощью Octoface.
После чего для модуля можно вызвать метод octo_configure, принимающий на вход
Symbol и блок с настройками. После этого за модулем фиксируется выбранная роль.
Пример для модуля Сore с ролью :core
```ruby
module Core
  extend Octoface
  octo_configure :core do

  end
end
```
Блок с настройками передаётся для исполнения классу Octoface::OctoConfig,
смотрите его документацию для использования его возможностей. Также имеется
много примеров использования.

### Face::MyMenu
Метод Face::MyMenu.add_item предназначен для добавления элемента меню (ссылки на
  модуль в главное меню пользователя).
* Первый аргумент -- уникальный ключ элемента.
* Второй аргумент -- название элемента.
* Третий аргумент -- путь (строка или регулярное выражение).
  Если он совпадает с текущим путём контроллера(params[:controller]), то пункт
  подсвечивается синим, что означает его активность.

Вариация метода  Face::MyMenu.add_item_if_may добавит для пользователя пункт меню,
если установлена связь между ability и контроллером с помощью OctoConfig#add_controller_ability и
у пользователя есть данная ability.


## Межмодульный интерфейс для представлений
В представления довольно частая ситуация, когда нужно обратиться к
элементам другого модуля. Здесь предлагается использовать метод custom_helper,
который передаёт все свои аргументы в метод handle_view класса Interface
модуля требуемой роли, если модуль присутствует в системе. Пример:
```
= custom_helper(:core, 'project_critical_technologies_id_in', f,
                label: t('.critical_technologies_id_in') )
```
Допускаются и другие пользовательские варианты. Для описания полей можно
описать наследника класса BootstrapFormHelper, если посчитаете, что он
облегчает описание методов. Такие наследники в Octoshell есть,
обращайтесь к ним за примерами.

## Межмодульное взаимодействие на уровне моделей
Здесь используются интерфейсы "класс-класс".
Проще рассмотреть на примере Ruby модуля Sessions::ReportProject,
который подмешивается(prepend) в Sessions::Report, если в системе есть модуль с ролью
core и внутри него модель "Проект".

Используется метод octo_use, который добавляет вспомогательные методы и записывает факт того, что класс Project
используется классом Report. Это можно посмотреть на странице /octoface/admin/roles
(в development-окружении из-за динамической подгрузки не всегда отображается верно).
Также осуществляется проверка того, что Project "разрешён"(на уровне соглашения)
к использованию вне модуля core. Смотрите модуль Octoface::Usage для деталей.

## link? и add_link
Эти простые методы позволяют отключать/включать функциональность. Смотрите
engines/sessions/lib/sessions.rb как пример.

## Hooks
Чистых межмодульных интерфейсов иногда недостаточно. Иногда нужно определять "место"
для встраивания других модулей. Например, информация о пользователе распределена между
модулями, а на его странице в панели администратора нужно видеть и отчёты из модуля Sessions,
и проекты из модуля Core и многое другое. Здесь помогают хуки.

На данный момент в Octoshell хуки используются  только для представлений.
В примере ниже регистрируется место для хука admin_users_show для роли main_app (базовое приложение)
 и передаётся аргумент по ключу user(должны же знать другие модули для какого именно пользователя надо отображать данные):
```
  /app/views/admin/users/show.html.slim
  = register_hook(:main_app,:admin_users_show, { user: @user })
```
Модуль Core добавляет  хук-представление core/hooks/admin_users_show
```ruby
  engines/core/lib/core.rb
  Octoface::Hook.add_hook(:core, "core/hooks/admin_users_show",
                          :main_app, :admin_users_show)
```

Представление выглядит следующим образом:
```
  = render "core/admin/employments/list", employments: user.employments.where(state: :active).order(primary: :desc, created_at: :desc)
  h4 = User.human_attribute_name(:projects)
  = render 'core/projects/projects_list', projects: user.projects.order(created_at: :desc)
  = render "core/admin/credentials/list", credentials: user.credentials.where(state: :active)
```

Места и хуки можно посмотреть на странице /octoface/admin/roles.





This project uses MIT-LICENSE.
