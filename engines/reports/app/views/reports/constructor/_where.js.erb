function init_where(){
  where_container = {
    items: [],
    alpaca: $("#main-form").alpaca('get').getControlByPath('where'),
    assign: function(enums,labels,prefix){
      this.items = [];
      for(var i in enums){
        this.items[i] = {
          enum: prefix.concat('.').concat(enums[i]),
          label:prefix.concat('.').concat(labels[i]),
          type: labels[i].split('|').slice(-1)[0]
        };
      }
    },
    append: function(enums, labels, prefix_array = []){
     var prefix = prefix_array.splice(1, prefix_array.length -1 ).join('.');
     if(prefix != ''){
       prefix = prefix.concat('.');
     }
     for(var i in enums){
       this.items.push({
         enum: prefix.concat(enums[i]),
         label: prefix.concat(labels[i]),
         type: labels[i].split('|').slice(-1)[0]
       });
     }
     // console.log(this.items);

     // this.alpaca.addItem(propertyId, itemSchema, itemOptions, itemData, insertAfterId, callback){
     //
     // }
    },
    get_items: function(){
      return this.items;
    },
    replace: function(old_begin, new_begin){
      var attributes_element = $("#main-form").alpaca('get').getControlByPath('attributes');
      // attributes_element.children = attributes_element.children
      //   .filter(word => !word.getValue().label.startsWith(begin));
      for(var i in attributes_element.children){
        var elem = attributes_element.children[i];
        var regex = RegExp(`^(${old_begin}\.)`,"g");
        var old_label = elem.getValue().label;
        var old_value = elem.getValue().value;
        elem.childrenByPropertyId.label.setValue(old_label.replace(regex,new_begin.concat('.')));
        elem.childrenByPropertyId.value.setValue(old_value.replace(regex,new_begin.concat('.')));
      }
      attributes_element.refresh();

    },
    remove: function(begin){
      // for(var i in this.alpaca.children){
      //   var elem = this.alpaca.children[i];
      //   console.log(elem.getValue());
      // }

      // this.alpaca.children = this.alpaca.children.filter(word => (word.getValue() == {} ||
      //   (word.getValue().all_attributes && !word.getValue().all_attributes.startsWith(begin))));
      // this.alpaca.refresh();
      if(!begin) return;

      var attributes_element = $("#main-form").alpaca('get').getControlByPath('attributes');
      attributes_element.children = attributes_element.children
        .filter(word => !word.getValue().label.startsWith(begin.concat('.')));
      attributes_element.refresh();
      this.items = this.items
        .filter(word => !word.enum.startsWith(begin.concat('.')));


      // this.init();
      // console.log(this.alpaca.children);
      // this.change();
      // self.alpaca.domEl.find('div.alpaca-container').prepend(button);

      // this.alpaca.refresh();
      // for(var i in this.alpaca.children){
      //   var elem = this.alpaca.children[i];
      //   elem.refresh();
      //   // console.log(elem.getValue());
      // }

      // for(var i in this.alpaca.children){
      //   var elem = this.alpaca.children[i];
      //   elem.childrenByPropertyId('all_children')
      //   for(var j in this.alpaca.children){
      //
      //   }
      //
      // }
      // this.change();
    },
    init: function(){
      var self = this;
    },
    change: function(){
      var self = this;
      for(var i in self.alpaca.children){
        for(var j in self.alpaca.children[i].children){
          var al = self.alpaca.children[i].children[j];
          if(al.propertyId == 'all_attributes'){
            al.schema.enum = self.items.map(a => a.enum);
            al.options.optionLabels = self.items.map(a => a.label);
            al.refresh();
          }

        }
      }
    },
    removeField: function(element){
      if(element){
        element.parent.removeItem(element.propertyId);
      }
    },
    second_operand_field: function(){
    var self = this;
    return {
    "schema": {
        "type": "object",
        "properties": {
            "choice": {
                "title": '<%=t(".choose_comparation")%>',
                "type": "string",
                "enum": ["attribute", "expression"],
                "required": true
            },
            "attribute": {
                // "title": "Pick a Flavour",
                "type": "string",
                "enum": self.items.map(a => a.enum)
            },
            "expression": {
                // "title": "Pick a Topping",
                "type": "string",
                // "enum": ["Marshmellow", "Chocolate Chip", "Caramel", "Cookie Dough"]
            }
        },
        "dependencies": {
            "attribute": ["choice"],
            "expression": ["choice"]
        }
    },
    "options": {
        "fields": {
            "attribute": {
                "optionLabels": self.items.map(a => a.label),
                "dependencies": {
                    "choice": "attribute"
                }
            },
            "expression": {
                "dependencies": {
                    "choice": "expression"
                }
            }
        }
    }
  }

    }
  }
}
